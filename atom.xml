<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kang`s blog</title>
  
  <subtitle>小窝</subtitle>
  <link href="http://ykhou.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://ykhou.gitee.io/"/>
  <updated>2021-03-10T13:27:08.403Z</updated>
  <id>http://ykhou.gitee.io/</id>
  
  <author>
    <name>KangKang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MergeSort</title>
    <link href="http://ykhou.gitee.io/2021/03/10/MergeSort/"/>
    <id>http://ykhou.gitee.io/2021/03/10/MergeSort/</id>
    <published>2021-03-10T09:17:47.000Z</published>
    <updated>2021-03-10T13:27:08.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思路及原理"><a href="#算法思路及原理" class="headerlink" title="算法思路及原理"></a>算法思路及原理</h2><blockquote><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列;</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置;</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置;</li><li>重复步骤3直到某一指针超出序列尾;</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol></blockquote><p><img src="/2021/03/10/MergeSort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="归并排序"></p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>序列每次都要分成两部分进行排序，共需要要logN + 1次，而每一行无论如何分，都需要N次排序，所以时间复杂度为N(logN + 1)，即O(nlogn)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>需要额外的空间N，O(N)。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，但是当这两个元素相同时，选择前者放入temp序列中，保证相同元素前后关系的不变，保证了算法的稳定性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123; <span class="comment">// merge算法稳定的原因</span></span><br><span class="line">    temp[k++] = arr[i++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        sort(arr, left, mid);</span><br><span class="line">        sort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, mid+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftPoint = left; <span class="comment">// 指针指向第一部分开始位置</span></span><br><span class="line">        <span class="keyword">int</span> rightPoint = mid; <span class="comment">// 指针指向第二部分开始位置</span></span><br><span class="line">        <span class="keyword">int</span> tempPoint = <span class="number">0</span>; <span class="comment">// 指针指向临时数组开始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (leftPoint &lt; mid &amp;&amp; rightPoint &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[leftPoint] &lt;= arr[rightPoint]) &#123;</span><br><span class="line">                temp[tempPoint++] = arr[leftPoint++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[tempPoint++] = arr[rightPoint++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftPoint &lt; mid) temp[tempPoint++] = arr[leftPoint++];</span><br><span class="line">        <span class="keyword">while</span> (rightPoint &lt;= right) temp[tempPoint++] = arr[rightPoint++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            arr[left + i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法思路及原理&quot;&gt;&lt;a href=&quot;#算法思路及原理&quot; class=&quot;headerlink&quot; title=&quot;算法思路及原理&quot;&gt;&lt;/a&gt;算法思路及原理&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后</summary>
      
    
    
    
    <category term="算法" scheme="http://ykhou.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="归并算法" scheme="http://ykhou.gitee.io/tags/%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>github相关问题</title>
    <link href="http://ykhou.gitee.io/2021/03/10/%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8Agithub/"/>
    <id>http://ykhou.gitee.io/2021/03/10/%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8Agithub/</id>
    <published>2021-03-10T07:47:27.000Z</published>
    <updated>2021-03-10T08:39:53.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、打不开github或打开速度慢"><a href="#一、打不开github或打开速度慢" class="headerlink" title="一、打不开github或打开速度慢"></a>一、打不开github或打开速度慢</h2><p>这几天不知道什么原因突然打不开github了，ping了一下居然没有ping通，就上网百度了一下。</p><ol><li>打开 &lt;ipaddress.com&gt; ,查询如下两个域名，并分别记录下其对应的ip<ul><li>github.com</li><li>github.global.ssl.fastly.net</li></ul></li></ol><p><img src="/2021/03/10/%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8Agithub/IPAddress.png" alt="IPAdress"></p><ol start="2"><li>修改C:\Windows\System32\drivers\etc中的hosts文件<ul><li><code>140.82.112.3 github.com</code></li><li><code>199.232.69.194 github.global.ssl.fastly.net</code></li></ul></li></ol><p><img src="/2021/03/10/%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8Agithub/hosts.png" alt="hosts"></p><ol start="3"><li>清理一下DNS<ul><li><code>ipconfig /flushdns</code></li></ul></li></ol><h2 id="二、git推送到github失败"><a href="#二、git推送到github失败" class="headerlink" title="二、git推送到github失败"></a>二、git推送到github失败</h2><p>在VSCode中推送代码时，遇到了下面的问题，timed out，查询后发现是使用VPN，设置了代理的原因。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li>首先关闭VPN，等几分钟，然后再推送一次，看一下是否成功。</li><li>如果上一步失败的话，查看git代理<ul><li><code>git config --global http.proxy</code></li><li><code>git config --global https.proxy</code></li></ul></li><li>如果有返回信息，则取消代理<ul><li><code>git config --global --unset http.proxy</code></li><li><code>git config --global --unset http.proxy</code></li></ul></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li>将代理端口改成自己VPN的代理端口，如我的是10808，大家一定要改成自己的端口<ul><li><code>git config --global http.proxy 127.0.0.1:10808</code></li><li><code>git config --global https.proxy 127.0.0.1:10808</code></li></ul></li></ol>]]></content>
    
    
    <summary type="html">打不开github或推送到github失败</summary>
    
    
    
    <category term="default" scheme="http://ykhou.gitee.io/categories/default/"/>
    
    
    <category term="default" scheme="http://ykhou.gitee.io/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>InsertionSort</title>
    <link href="http://ykhou.gitee.io/2021/03/09/InsertionSort/"/>
    <id>http://ykhou.gitee.io/2021/03/09/InsertionSort/</id>
    <published>2021-03-09T08:46:23.000Z</published>
    <updated>2021-03-09T12:07:53.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思路及原理"><a href="#算法思路及原理" class="headerlink" title="算法思路及原理"></a>算法思路及原理</h2><blockquote><p>插入排序是指在待排序的元素中，假设前面n-1(其中n&gt;=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程。</p></blockquote><p><img src="/2021/03/09/InsertionSort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt="插入排序"></p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>当元素初始状态为正序时，只需要当前元素与前一元素作比较就可以结束排序，一共需要比较n-1次，O(n);<br>当元素初始状态为逆序时，需要比较并交换每一次的相邻元素，O(n^2);<br>故平均时间复杂度为o(n^2)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>不需要额外空间，O(1)。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>插入排序就是把后一个元素往前调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以插入排序是一种稳定排序算法。</p><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>样本小且基本有序的时候效率很高</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><blockquote><p>不使用swap方法，设置一个temp变量来存储需要排序的元素，如果temp比前一个元素小，就直接<code>arr[j] = arr[j-1]</code>，依次向前比较，直到temp比前一个元素大，就让对应位置的值为temp。</p></blockquote><p><img src="/2021/03/09/InsertionSort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96.png" alt="插入算法优化"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> s = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                    s = j-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[s] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">插入排序及其优化</summary>
    
    
    
    <category term="算法" scheme="http://ykhou.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="插入排序" scheme="http://ykhou.gitee.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>BubbleSort</title>
    <link href="http://ykhou.gitee.io/2021/03/06/BubbleSort/"/>
    <id>http://ykhou.gitee.io/2021/03/06/BubbleSort/</id>
    <published>2021-03-06T10:23:12.000Z</published>
    <updated>2021-03-09T12:08:08.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思路及原理"><a href="#算法思路及原理" class="headerlink" title="算法思路及原理"></a>算法思路及原理</h2><blockquote><p>1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2、对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3、针对所有的元素重复以上的步骤，除了最后一个。<br>4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></blockquote><p><img src="/2021/03/06/BubbleSort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>当元素初始状态为正序时，只需要第一次判断就可以结束排序，O(n);<br>当元素初始状态为逆序时，需要比较并交换每一次的相邻元素，O(n^2);<br>故平均时间复杂度为o(n^2)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>不需要额外空间，O(1)。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>未优化前的代码，最坏复杂度也是O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minPos = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minPos = arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, minPos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><blockquote><p>每次遍历时，先将标志位置为false，然后判断后面的元素是否发生了交换，如果发生交换，将flag改为true，当未发生交换时，flag仍为flase，最后对判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        sort(arr);</span><br><span class="line">        printArr(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 是否交换的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">                    flag = <span class="keyword">true</span>; <span class="comment">// 只要发生了交换，flag就改为true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return</span></span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">冒泡排序及其优化</summary>
    
    
    
    <category term="算法" scheme="http://ykhou.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="冒泡排序" scheme="http://ykhou.gitee.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>SelectionSort</title>
    <link href="http://ykhou.gitee.io/2021/03/06/SelectionSort/"/>
    <id>http://ykhou.gitee.io/2021/03/06/SelectionSort/</id>
    <published>2021-03-06T08:50:36.000Z</published>
    <updated>2021-03-09T12:08:37.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思路及原理"><a href="#算法思路及原理" class="headerlink" title="算法思路及原理"></a>算法思路及原理</h2><blockquote><p>首先在所有未排序的元素中找出最小值，放到首位，然后在剩余未排序的元素中找到最小值，放到第二位置，以次类推</p></blockquote><p><img src="/2021/03/06/SelectionSort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>选择排序的外层为 n-1 次，比较操作为 n(n-1)/2 次。时间复杂度为O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+…+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>不需要额外的空间，O(1)。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个<strong>不稳定</strong>的排序算法。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 选择排序</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minPos = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minPos = arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, minPos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><blockquote><p>在每次循环时，选择最大和最小值同时进行排序，最小值放首位，最大值放末尾。但是当首位等于最大值和末尾等于最小值时要特殊考虑。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minPos = i;</span><br><span class="line">            <span class="keyword">int</span> maxPos = arr.length-i-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minPos]) minPos = j;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[maxPos]) maxPos = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == maxPos &amp;&amp; arr.length-i-<span class="number">1</span> != minPos) &#123;</span><br><span class="line">                swap(arr, arr.length - i - <span class="number">1</span>, maxPos);</span><br><span class="line">                swap(arr, i, minPos);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != maxPos &amp;&amp; arr.length-i-<span class="number">1</span> == minPos) &#123;</span><br><span class="line">                swap(arr, i, minPos);</span><br><span class="line">                swap(arr, arr.length - i - <span class="number">1</span>, maxPos);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == maxPos &amp;&amp; arr.length-i-<span class="number">1</span> == minPos) &#123;</span><br><span class="line">                swap(arr, maxPos, minPos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(arr, i, minPos);</span><br><span class="line">                swap(arr, arr.length - i - <span class="number">1</span>, maxPos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">选择排序及其优化</summary>
    
    
    
    <category term="算法" scheme="http://ykhou.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="选择排序" scheme="http://ykhou.gitee.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="http://ykhou.gitee.io/2021/02/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://ykhou.gitee.io/2021/02/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-02-28T09:59:51.000Z</published>
    <updated>2021-02-28T10:00:42.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Lambda表达式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">Ilike</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I like lambda2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ilike like = <span class="keyword">new</span> Like();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> Like2();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">Ilike</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I like lambda3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> Like3();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.匿名内部类</span></span><br><span class="line">        like = <span class="keyword">new</span> Ilike() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I like lambda4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.用lambda简化</span></span><br><span class="line">        like = ()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I like lambda5&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ilike</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like</span> <span class="keyword">implements</span> <span class="title">Ilike</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I like lambda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Lambda表达式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://ykhou.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://ykhou.gitee.io/tags/Java/"/>
    
    <category term="Lambda" scheme="http://ykhou.gitee.io/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoader</title>
    <link href="http://ykhou.gitee.io/2021/02/28/ClassLoader/"/>
    <id>http://ykhou.gitee.io/2021/02/28/ClassLoader/</id>
    <published>2021-02-28T09:24:15.000Z</published>
    <updated>2021-03-09T12:03:53.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h2><p>Class文件需要加载到虚拟机中之后才能运行和使用。</p><p>包括主要三步：加载-&gt;链接-&gt;初始化，链接过程又包括三步：验证-&gt;准备-&gt;解析。</p><p><img src="/2021/02/28/ClassLoader/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="Java类加载过程"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><blockquote><p>将class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。</p></blockquote><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p></blockquote><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote><p>正式为类变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote><p>虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote><ul><li>执行类构造器&lt; clinit &gt;()方法的过程，将所有类变量的赋值动作和静态代码块的语句运行</li><li>初始化一个类时，如果其父类还没有初始化，则先触发其父类的初始化</li><li>虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步</li></ul></blockquote><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><ol><li>启动（Bootstrap）类加载器或根加载器<ul><li>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 &lt; JAVA_HOME &gt;/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。</li></ul></li><li>扩展（Extension）类加载器<ul><li>扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载&lt; JAVA_HOME &gt;/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</li></ul></li><li>应用程序加载器<ul><li>也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。</li></ul></li></ol><h2 id="三、双亲委派机制"><a href="#三、双亲委派机制" class="headerlink" title="三、双亲委派机制"></a>三、双亲委派机制</h2><blockquote><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p></blockquote><p><img src="/2021/02/28/ClassLoader/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="双亲委派机制"></p><p>AppClassLoader的父类加载器为ExtClassLoader ExtClassLoader的父类加载器为null，null并不代表ExtClassLoader没有父类加载器，而是 BootstrapClassLoader 。因为java底层是由C语音编写的，所以返回为null。</p>]]></content>
    
    
    <summary type="html">类加载过程以及双亲委派机制</summary>
    
    
    
    <category term="学习笔记" scheme="http://ykhou.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://ykhou.gitee.io/tags/Java/"/>
    
    <category term="JVM" scheme="http://ykhou.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="http://ykhou.gitee.io/2021/02/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://ykhou.gitee.io/2021/02/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-02-28T08:04:41.000Z</published>
    <updated>2021-03-09T12:01:57.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、堆空间"><a href="#一、堆空间" class="headerlink" title="一、堆空间"></a>一、堆空间</h2><p>垃圾回收机制主要工作于堆，那么让我们首先了解一下堆空间的基本结构</p><ul><li>新生代<ul><li>Eden区</li><li>From Survivor</li><li>To Survivor</li></ul></li><li>老年代</li></ul><p><img src="/2021/02/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/java%E5%A0%86.png" alt="java堆"></p><p>大部分情况，对象都会首先在<strong>Eden区</strong>分配，在一次新生代垃圾回收后，如果对象还存活，则会进入<strong>幸存区</strong>，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到<strong>老年代</strong>中。</p><p>经过一次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次 GC 前的“From”，新的”From”就是上次 GC 前的”To”。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p><h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>大对象是需要大量连续内存空间的对象(字符串、数组等)，将直接进入老年代。为了避免为对象分配内存时由于分配担保机制带来的复制而降低效率</p><h3 id="轻GC和重GC"><a href="#轻GC和重GC" class="headerlink" title="轻GC和重GC"></a>轻GC和重GC</h3><ul><li>轻GC/部分收集(Partial GC)<ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集</li></ul></li><li>重GC/整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li></ul><h2 id="二、如何判断垃圾"><a href="#二、如何判断垃圾" class="headerlink" title="二、如何判断垃圾"></a>二、如何判断垃圾</h2><p>堆中存放着大部分的对象实例，那如何判断这个对象是一个垃圾呢(即这个对象已经死亡/不再被任何途径使用的对象)</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><blockquote><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p></blockquote><p>这个方法实现简单，效率高，但是目前主流的虚拟机(如python就是采用的引用计数法)中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</p><p>所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">         </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">         </span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object object = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>为了解决这个问题，在Java中采取了可达性分析法。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。</p><p><img src="/2021/02/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/GC-roots.png" alt="GC roots"></p><p>在Java语言中，可作为 GC Roots 的对象包括下面几种：</p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中 JNI（Native方法）引用的对象</li></ol><h3 id="强、软、弱、虚引用"><a href="#强、软、弱、虚引用" class="headerlink" title="强、软、弱、虚引用"></a>强、软、弱、虚引用</h3><ol><li>强引用是指在程序代码之中普遍存在的，类似”Object obj=new Object()”这类的引用，垃圾收集器永远不会回收存活的强引用对象。</li><li>软引用是指还有用但并非必需的对象。在系统 将要发生内存溢出异常之前 ，将会把这些对象列进回收范围之中进行第二次回收。</li><li>弱引用也是用来描述非必需对象的，被弱引用关联的对象 只能生存到下一次垃圾收集发生之前 。当垃圾收集器工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。</li><li>虚引用是最弱的一种引用关系。 无法通过虚引用来取得一个对象实例 。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ol><h2 id="三、垃圾收集算法"><a href="#三、垃圾收集算法" class="headerlink" title="三、垃圾收集算法"></a>三、垃圾收集算法</h2><p>共有4种:</p><ul><li>标记-清除算法</li><li>复制算法</li><li>标记整理算法</li><li>分代收集算法</li></ul><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><blockquote><p>该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p></blockquote><ul><li>效率问题，标记和清除两个过程的效率都不高；</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><p>示意图如下：</p><p><img src="/2021/02/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记-清除算法"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><blockquote><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p></blockquote><p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。复制算法的执行过程如下图：</p><p><img src="/2021/02/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p><p>不过因为新生代中的对象大都存活时间较少，所以也不是按照1:1的比例进行划分空间的，而是分为了Eden(80%)和两块Survivor(各10%)，每次使用Eden和一块Survivor。</p><p>当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。<br>很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><blockquote><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p></blockquote><p>“标记-整理”算法的示意图如下：</p><p><img src="/2021/02/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法"></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><blockquote><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p></blockquote><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h2 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。有以下几种</p><ul><li>Serial收集器</li><li>Serial Old收集器</li><li>ParNew收集器</li><li>Parallel Scavenge收集器</li><li>Parallel Old收集器</li><li>CMS收集器</li><li>G1收集器</li><li>ZGC收集器</li></ul><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>与Serial相似但不相同，因为Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p><h3 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、堆空间&quot;&gt;&lt;a href=&quot;#一、堆空间&quot; class=&quot;headerlink&quot; title=&quot;一、堆空间&quot;&gt;&lt;/a&gt;一、堆空间&lt;/h2&gt;&lt;p&gt;垃圾回收机制主要工作于堆，那么让我们首先了解一下堆空间的基本结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生代&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://ykhou.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://ykhou.gitee.io/tags/Java/"/>
    
    <category term="JVM" scheme="http://ykhou.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习</title>
    <link href="http://ykhou.gitee.io/2021/02/26/JVM%E5%AD%A6%E4%B9%A0/"/>
    <id>http://ykhou.gitee.io/2021/02/26/JVM%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-02-26T13:21:14.000Z</published>
    <updated>2021-03-09T11:58:30.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、JVM位置"><a href="#1、JVM位置" class="headerlink" title="1、JVM位置"></a>1、JVM位置</h3><p><img src="/2021/02/26/JVM%E5%AD%A6%E4%B9%A0/JVM%E4%BD%8D%E7%BD%AE.png" alt="JVM位置"></p><h3 id="2、JVM的体系结构"><a href="#2、JVM的体系结构" class="headerlink" title="2、JVM的体系结构"></a>2、JVM的体系结构</h3><p><img src="/2021/02/26/JVM%E5%AD%A6%E4%B9%A0/JVM%E7%BB%93%E6%9E%84.png" alt="JVM体系结构"></p><h3 id="3、类加载器"><a href="#3、类加载器" class="headerlink" title="3、类加载器"></a>3、类加载器</h3><p>类加载过程：</p><ol><li>加载<ul><li>将class文件字节码内容加载到内存中，并对这些静态数据转换成方法区的的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象</li></ul></li><li>链接<ul><li>验证:目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li><li>准备:正式为类变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配</li><li>解析:虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程</li></ul></li><li>初始化<ul><li>执行类构造器&lt; clinit &gt;()方法的过程，将所有类变量的赋值动作和静态代码块的语句运行</li><li>初始化一个类时，如果其父类还没有初始化，则先触发其父类的初始化</li><li>虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步</li></ul></li></ol><p>三种类加载器</p><ol><li>启动（Bootstrap）类加载器或根加载器<ul><li>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。</JAVA_HOME></li></ul></li><li>扩展（Extension）类加载器<ul><li>扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</JAVA_HOME></li></ul></li><li>系统（System）类加载器/应用程序加载器<ul><li>也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。</li></ul></li></ol><h3 id="4、双亲委派机制"><a href="#4、双亲委派机制" class="headerlink" title="4、双亲委派机制"></a>4、双亲委派机制</h3><blockquote><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p></blockquote><h3 id="5、沙箱安全机制"><a href="#5、沙箱安全机制" class="headerlink" title="5、沙箱安全机制"></a>5、沙箱安全机制</h3><blockquote><p>Java安全模型的核心就是Java沙箱。沙箱机制就是讲Java代码限定在虚拟机JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。</p></blockquote><p>沙箱主要限制系统资源访问，例如：CPU、内存、文件系统、网络。不同级别的啥想对这些资源访问的限制也可以不一样</p><p>当前最新的安全机制实现，引入了域（Domain）的概念。虚拟机吧所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互。而各个域应用部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。</p><p>通俗来说就是虚拟机把代码加载到拥有不同权限的域里，然后代码就拥有了该域的所有权限。这样就能控制不同代码拥有不同调用操作系统和本地资源的权限</p><p>沙箱包括：</p><ul><li>字节码校验器</li><li>类装载器</li></ul><h3 id="6、Native"><a href="#6、Native" class="headerlink" title="6、Native"></a>6、Native</h3><blockquote><p>凡是带了native关键字的，说明java的作用范围达不到了，会去调用底层C语言的库。</p></blockquote><p>加上native的语句:</p><ul><li>会进入本地方法栈</li><li>调用本地方法接口（JNI）</li></ul><p>JVM在内存中专门开辟了一块标记区域：Native Method Stack 登记native方法 在最终执行的时候，加载本地方法库中的方法通过JNI    </p><h3 id="7、方法区"><a href="#7、方法区" class="headerlink" title="7、方法区"></a>7、方法区</h3><blockquote><p>方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如：构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间</p></blockquote><ul><li>静态变量（static）、常量（final）、类信息Class（构造方法、接口定义）、运行时的常量池存在于方法区中，但是实例变量存在于堆内存中，和方法区无关 （jdk8后 常量池放在了堆里）</li></ul><h3 id="8、栈"><a href="#8、栈" class="headerlink" title="8、栈"></a>8、栈</h3><blockquote><p>栈：先进后出 后进先出</p><p>队列：先进先出 后进后出 （FIFO ：First Input First Output）</p></blockquote><p>程序运行就是一个栈，main方法先执行 所以main方法先进栈，然后后面调用的方法以此进栈，后面的方法执行完了弹出栈最后弹出的是main（），所以程序的main方法都是最后结束</p><p>栈：栈内存，主管程序的运行，生命周期和线程同步。线程结束，栈内存也就释放了，对于栈来说 不存在垃圾回收问题 一旦线程结束 栈就over</p><p>栈里压的东西：8大基本类型、对象引用、实例的方法</p><p>栈运行的原理：栈帧</p><p><img src="/2021/02/26/JVM%E5%AD%A6%E4%B9%A0/%E6%A0%88%E3%80%81%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="栈、堆和方法区"></p><h3 id="9、三种JVM"><a href="#9、三种JVM" class="headerlink" title="9、三种JVM"></a>9、三种JVM</h3><ul><li>Sun公司 HotSpot</li><li>BEA公司 JRockit</li><li>IBM J9VM</li></ul><h3 id="10、堆-Heap"><a href="#10、堆-Heap" class="headerlink" title="10、堆(Heap)"></a>10、堆(Heap)</h3><p>一个JVM只有一个堆内存，堆内存的大小是可以调节的。</p><p>类加载器读取了类文件后，一般会把类的具体实例、方法、常量、变量放在堆中，保存我们所有引用类型的真实对象；</p><p>堆内存中还要细分为三个区域：</p><ul><li>新生区(伊甸园区) Young/New</li><li>老年区 Old</li><li>永久区 Perm</li></ul><p>GC垃圾回收主要在伊甸园区和养老区<br>堆内存满了会报出OOM（OutOfMemoryError：java heap space）错误，堆内存不够。</p><p><img src="/2021/02/26/JVM%E5%AD%A6%E4%B9%A0/%E5%A0%86.png" alt="堆"></p><p>在JDK8以后，永久存储区改了名字 叫元空间,元空间逻辑上存在，但物理上可能并不存在。</p><h4 id="新生区-Eden-、老年区-Old"><a href="#新生区-Eden-、老年区-Old" class="headerlink" title="新生区(Eden)、老年区(Old)"></a>新生区(Eden)、老年区(Old)</h4><p>新生区包括伊甸园区和幸存者区<br>伊甸园区，所有的对象都是在伊甸园区new出来的。当伊甸园区装满就会进行一次轻GC。假设该对象在GC垃圾回收中能存活下来一次 就进入幸存者区<br>幸存者区（from,to）：当幸存者区装满 就会触发重GC 存活下来的进入养老区。幸存者区是动态的，from,to区域会互换</p><p>经过研究，99%的对象都是临时对象，不会走到养老区。</p><h4 id="永久区-Perm"><a href="#永久区-Perm" class="headerlink" title="永久区(Perm)"></a>永久区(Perm)</h4><p>该区域常驻内存。用来存放一些JDK自身携带的Class对象、Interface元数据。存储的是Java运行时的一些环境或类信息。这个区域不存在垃圾回收。关闭虚拟机的时候就会释放永久区的内存。</p><p>一个启动类加载了大量的第三方jar包，或者tomcat部署了太多的应用，或者大量的动态生成的反射类。就会导致永久区内存被装满，就会产生OOM。</p><p>方法区存在于永久区内（也叫非堆（只是个名词，其实也是堆））</p><p>JDK1.6之前：永久代，常量池是在方法区<br>JDK1.7：永久代，但是慢慢退化了（去永久代），常量池在堆中<br>JDK1.8之后：无永久代，常量池在元空间</p><p><img src="/2021/02/26/JVM%E5%AD%A6%E4%B9%A0/%E5%A0%862.png" alt="堆2"></p><h3 id="11、GC-垃圾回收机制"><a href="#11、GC-垃圾回收机制" class="headerlink" title="11、GC(垃圾回收机制)"></a>11、GC(垃圾回收机制)</h3><blockquote><p>作用区:堆(堆和方法区)</p></blockquote><p>JVM在进行GC时，有三个区域：</p><ul><li>伊甸园区</li><li>幸存区（from，to）</li><li>老年区</li></ul><p>JVM在进行GC垃圾回收时，并不是对这三个区域统一回收，大部分时候，回收都是伊甸园区</p><p>GC有两类：轻GC（普通GC），重GC（全局GC\Full GC）</p><p>GC的算法有：标记清除法、标记压缩法、复制算法、引用计数法</p><ul><li>引用计数法：各个对象每用一次，该对象计数器就+1（计数器本身也要有消耗）。当计数器为0时，说明该对象没有，就立刻进行垃圾回收。</li></ul><h3 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h3><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3>]]></content>
    
    
    <summary type="html">Java虚拟机学习，一些问题</summary>
    
    
    
    <category term="学习笔记" scheme="http://ykhou.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="http://ykhou.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>简单剖析Java中的装箱和拆箱</title>
    <link href="http://ykhou.gitee.io/2021/02/19/%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90Java%E4%B8%AD%E7%9A%84%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/"/>
    <id>http://ykhou.gitee.io/2021/02/19/%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90Java%E4%B8%AD%E7%9A%84%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</id>
    <published>2021-02-19T12:28:28.000Z</published>
    <updated>2021-02-20T07:18:11.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在 Java 的设计中提倡一种思想，即一切皆对象。于是 Java 将基本数据类型封装成对象，每种基本数据类型分别设计了对应的类，称之为包装类（Wrapper Classes）。</p></blockquote><table><thead><tr><th align="left">基本数据类型</th><th align="left">包装类</th></tr></thead><tbody><tr><td align="left">byte</td><td align="left">Byte</td></tr><tr><td align="left">short</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">Long</td></tr><tr><td align="left">char</td><td align="left">Character</td></tr><tr><td align="left">float</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">Double</td></tr><tr><td align="left">boolean</td><td align="left">Boolean</td></tr></tbody></table><p>将基本数据类型封装成对象就可以在对象中定义更多的功能方法操作</p><h2 id="拆箱与装箱"><a href="#拆箱与装箱" class="headerlink" title="拆箱与装箱"></a>拆箱与装箱</h2><p>那什么是拆箱？什么是装箱呢？</p><ul><li>装箱：把基本数据类型转换为对应的包装类类型</li><li>拆箱：把包装类类型转换成对应的基本数据类型</li></ul><p>Java 1.5 版本之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行装箱及拆箱操作，不用在进行手工操作，为开发者提供了更多的方便。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer obj = <span class="number">123</span>; <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">int</span> i = obj; <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure><p>自动装箱，相当于Java编译器替我们执行了 <code>Integer.valueOf(XXX)</code>;<br>自动拆箱，相当于Java编译器替我们执行了 <code>Integer.intValue(XXX)</code>;</p><h2 id="包装类的应用"><a href="#包装类的应用" class="headerlink" title="包装类的应用"></a>包装类的应用</h2><h3 id="int和Integer相互转换"><a href="#int和Integer相互转换" class="headerlink" title="int和Integer相互转换"></a>int和Integer相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer obj = <span class="keyword">new</span> Integer(<span class="number">50</span>); <span class="comment">// 手动装箱</span></span><br><span class="line"><span class="keyword">int</span> n = obj.intValue(); <span class="comment">// 手动拆箱</span></span><br></pre></td></tr></table></figure><h3 id="数值类型转为字符串类型"><a href="#数值类型转为字符串类型" class="headerlink" title="数值类型转为字符串类型"></a>数值类型转为字符串类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int -&gt; string</span></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">String s1 = <span class="string">&quot;&quot;</span> + number;</span><br><span class="line"></span><br><span class="line">String s2 = String.valueOf(number);</span><br><span class="line"></span><br><span class="line">String s3 = Integer.toString(number);</span><br></pre></td></tr></table></figure><h3 id="字符串转为数值类型"><a href="#字符串转为数值类型" class="headerlink" title="字符串转为数值类型"></a>字符串转为数值类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string -&gt; int</span></span><br><span class="line">String s = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">Integer i = Integer.valueOf(s);</span><br><span class="line"><span class="keyword">int</span> x1 = i.intValue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x2 = Integer.parseInt(s);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 Java 的设计中提倡一种思想，即一切皆对象。于是 Java 将基本数据类型封装成对象，每种基本数据类型分别设</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://ykhou.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://ykhou.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java数据类型</title>
    <link href="http://ykhou.gitee.io/2021/02/19/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://ykhou.gitee.io/2021/02/19/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-02-19T08:00:07.000Z</published>
    <updated>2021-03-09T11:58:07.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近学习equals方法时，遇到了一个问题，那就是String属于什么数据类型<br>平时总喜欢把int、String类型混在一起，但是它真的和int属于同一类型吗</p></blockquote><h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><p>java提供两种不同的数据类型:基本数据类型和引用数据类型</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型共八种，分为三大类。除了这八种，其余的都是引用数据类型。<br><img src="/2021/02/19/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="基本数据类型"></p><ol><li>基本数据类型的值是一个简单的数字，字符或布尔值，java虚拟机会为其分配数据类型实际占用的内存空间;</li><li>基本数据类型的变量是局部变量时，存储在栈里面;是成员变量时，存放在堆里;</li><li>基本数据类型的值是不可变的(不能给基本数据类型添加属性和方法);</li><li>基本数据类型的比较是值的比较(他们的值相等时就是相等的)。</li></ol><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>引用数据类型可以分为：类、接口、数组。<br><img src="/2021/02/19/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="引用数据类型"></p><ol><li>引用数据类型的变量的值是一个地址，而这个地址指向的堆内存中的一个值或一组值;</li><li>引用数据类型的值是可变的，且可以拥有属性和方法</li></ol><p>其中字符串String属于引用数据类型，因为String属于一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;China&quot;</span>;</span><br><span class="line">String b = a; <span class="comment">// a、b都指向常量池中的China</span></span><br><span class="line"></span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;China&quot;</span>);</span><br><span class="line">String d = c; <span class="comment">// c、d存储同一个地址，这个地址指向栈中的China</span></span><br></pre></td></tr></table></figure><h2 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h2><h3 id="使用-比较"><a href="#使用-比较" class="headerlink" title="使用==比较"></a>使用==比较</h3><p>对于基本数据类型：比较值是否相等<br>对于引用数据类型：比较地址是否相同</p><h3 id="使用equals比较"><a href="#使用equals比较" class="headerlink" title="使用equals比较"></a>使用equals比较</h3><p>equals方法是Object类的一个方法，Java当中所有的类都是继承于Object这个超类。如果没有对该方法进行重写的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。<br>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际使用中，一般会重写定义的class的equals方法，如String类的equals源码如下。<br>即两个字符串使用 == 相等  或者  两个字符串的所有组成字符都相等返回true，其他情况返回false。这里就定义String根据equals方法判断是否相等的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (object == <span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (object <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">   String s1 = <span class="keyword">this</span>;</span><br><span class="line">   String s2 = (String) object;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> s1len = s1.lengthInternal();</span><br><span class="line">   <span class="keyword">int</span> s2len = s2.lengthInternal();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (s1len != s2len) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">byte</span>[] s1Value = s1.value;</span><br><span class="line">   <span class="keyword">byte</span>[] s2Value = s2.value;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (s1Value == s2Value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There was a time hole between first read of s.hashCode and second read if another thread does hashcode</span></span><br><span class="line">    <span class="comment">// computing for incoming string object</span></span><br><span class="line">    <span class="keyword">int</span> s1hash = s1.hashCode;</span><br><span class="line">    <span class="keyword">int</span> s2hash = s2.hashCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1hash != <span class="number">0</span> &amp;&amp; s2hash != <span class="number">0</span> &amp;&amp; s1hash != s2hash) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和equals的区别-1"><a href="#和equals的区别-1" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h3><ul><li>String str = “China”; 先在内存中找是不是有”China”这个对象,如果有，就让str指向那个”China”.如果内存里没有”China”，就创建一个新的对象保存”China”;</li><li>String str=new String(“China”) 是不管内存里是不是已经有”China”这个对象，都新建一个对象保存”China”。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;China&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;China&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;China&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;China&quot;</span>; <span class="comment">// 从常量池中查找 China</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false,非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true,重写</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象;数值在范围外时，都会创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x1 = <span class="number">3</span>;</span><br><span class="line">        Integer y1 = <span class="number">3</span>;</span><br><span class="line">        Integer x2 = <span class="number">300</span>;</span><br><span class="line">        Integer y2 = <span class="number">300</span>;</span><br><span class="line">        System.out.println(x1 == y1);<span class="comment">// true</span></span><br><span class="line">        System.out.println(x2 == y2);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">        System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">什么！还有人在问String属于什么类型？ ==和equals的区别</summary>
    
    
    
    <category term="学习笔记" scheme="http://ykhou.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://ykhou.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>VsCode以管理员模式运行终端</title>
    <link href="http://ykhou.gitee.io/2021/02/17/VsCode%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF/"/>
    <id>http://ykhou.gitee.io/2021/02/17/VsCode%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF/</id>
    <published>2021-02-17T02:50:05.000Z</published>
    <updated>2021-03-09T11:58:48.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>之前一直在ubuntu系统下运行终端，现在回到windows下后，每次将终端位置调到对应文件夹感觉很麻烦，于是想在VsCode下面的终端进行操作，但是发现系统禁止运行脚本</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo : 无法加载文件 C:\Users\kangkang\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=<span class="number">135170</span> 中的 about </span><br><span class="line">_Execution_Policies。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ hexo</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>将VsCode改为以管理员模式运行</li></ol><p><img src="/2021/02/17/VsCode%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%BB%88%E7%AB%AF/VsCode%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C.png" alt="以管理员模式运行"></p><ol start="2"><li>在VsCode的终端中运行get-ExecutionPolicy,显示Restricted,表示状态是禁止的</li><li>然后运行set-ExecutionPolicy RemoteSigned</li></ol><blockquote><p>成功解决</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前一直在ubuntu系统下运行终端，现在回到windows下后，每次将终端位置调到对应文件夹感觉</summary>
      
    
    
    
    <category term="知识分享" scheme="http://ykhou.gitee.io/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="VsCode" scheme="http://ykhou.gitee.io/tags/VsCode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github/Gitee</title>
    <link href="http://ykhou.gitee.io/2021/01/10/Hexo-Github-Gitee/"/>
    <id>http://ykhou.gitee.io/2021/01/10/Hexo-Github-Gitee/</id>
    <published>2021-01-10T09:15:41.000Z</published>
    <updated>2021-02-19T07:55:57.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Hexo框架"><a href="#一、Hexo框架" class="headerlink" title="一、Hexo框架"></a>一、Hexo框架</h2><blockquote><p>Hexo is a fast, simple and powerful blog framework.</p></blockquote><h3 id="Requirement"><a href="#Requirement" class="headerlink" title="Requirement"></a>Requirement</h3><ul><li>Node.js</li><li>Git</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><ul><li>安装完成后，检查安装环境</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">git - version</span><br></pre></td></tr></table></figure><ul><li>出现版本号即安装成功</li></ul><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>安装完成后，初始化hexo，安装插件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init MyBlog //MyBlog为你的博客文件夹，名字自定</span><br><span class="line">cd MyBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>以Mylog为根目录，打开终端，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>会看到提示Hexo is running at <a class="link" href="http://localhost:4000/">http://localhost:4000<i class="fas fa-external-link-alt"></i></a>，浏览器中打开即可本地预览<br>按下Ctrl+c即可停止服务</p><blockquote><p>到此，本地博客搭建成功</p></blockquote><h2 id="二、Github-Gitee"><a href="#二、Github-Gitee" class="headerlink" title="二、Github/Gitee"></a>二、Github/Gitee</h2><h3 id="注册-Github-Gitee"><a href="#注册-Github-Gitee" class="headerlink" title="注册 Github/Gitee"></a>注册 Github/Gitee</h3><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><h3 id="配置-SSHKey"><a href="#配置-SSHKey" class="headerlink" title="配置 SSHKey"></a>配置 SSHKey</h3><h3 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><blockquote><p>到此，博客部署完成</p></blockquote><h2 id="三、更改主题"><a href="#三、更改主题" class="headerlink" title="三、更改主题"></a>三、更改主题</h2><p>到hexo官网<a class="link" href="https://hexo.io/themes/">https://hexo.io/themes/<i class="fas fa-external-link-alt"></i></a>可以找到数百种主题<br>下载之后复制到theme文件夹下，并在_config.yml文件中更改主题名字</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">keep</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">如何使用hexo+github建立一个属于自己的博客</summary>
    
    
    
    <category term="知识分享" scheme="http://ykhou.gitee.io/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Hexo" scheme="http://ykhou.gitee.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记</title>
    <link href="http://ykhou.gitee.io/2021/01/10/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://ykhou.gitee.io/2021/01/10/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-10T09:15:41.000Z</published>
    <updated>2021-02-19T07:59:53.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="1、注释"><a href="#1、注释" class="headerlink" title="1、注释"></a>1、注释</h3><ul><li>单行注释<ul><li>// 注释信息</li></ul></li><li>多行注释<ul><li>/<em>注释信息</em>/</li></ul></li><li>文档注释<ul><li>/<strong>注释信息</strong>/</li></ul></li></ul><h3 id="2、关键字"><a href="#2、关键字" class="headerlink" title="2、关键字"></a>2、关键字</h3><ul><li>关键字的字母全部小写</li></ul><h3 id="3、常量"><a href="#3、常量" class="headerlink" title="3、常量"></a>3、常量</h3><ul><li>字符串常量<ul><li>双引号括起来的内容，如 “helloworld”</li></ul></li><li>整数常量<ul><li>不带小数的数字，如 22,33</li></ul></li><li>小数常量<ul><li>带小数的数字，如 22.3</li></ul></li><li>字符常量<ul><li>用单引号括起来的内容，如 ‘A’,’我’</li></ul></li><li>布尔常量<ul><li>true，false</li></ul></li><li>空常量<ul><li>一个特殊的值，null</li></ul></li></ul><h3 id="4、数据类型"><a href="#4、数据类型" class="headerlink" title="4、数据类型"></a>4、数据类型</h3><ul><li>基本数据类型<ul><li>数值型<ul><li>整数（byte，short，int，long）</li><li>浮点型（float，double）</li><li>字符（char）</li></ul></li><li>非数值型<ul><li>布尔（boolean）</li></ul></li></ul></li><li>引用数据类型</li></ul><h3 id="5、变量"><a href="#5、变量" class="headerlink" title="5、变量"></a>5、变量</h3><ul><li>默认为int和double类型</li><li>当要定义long类型的变量时，后面要加一个L，如 l = 100000000L</li><li>当定义float类型的变量时，后面加一个F，如 f = 13.14F</li></ul><h3 id="6、标识符"><a href="#6、标识符" class="headerlink" title="6、标识符"></a>6、标识符</h3><ul><li>规则<ul><li>由数字、字母、下划线、美元符组成</li><li>不能以数字开头</li><li>不能是关键字</li><li>区分大小写</li></ul></li><li>命名法<ul><li>小驼峰命名法<ul><li>方法和变量</li></ul></li><li>大驼峰命名法<ul><li>类class</li></ul></li></ul></li></ul><h3 id="7、类型转换"><a href="#7、类型转换" class="headerlink" title="7、类型转换"></a>7、类型转换</h3><ul><li>自动类型转换</li><li>强制类型转换</li></ul><h2 id="二、运算符"><a href="#二、运算符" class="headerlink" title="二、运算符"></a>二、运算符</h2><h3 id="1、算术运算符"><a href="#1、算术运算符" class="headerlink" title="1、算术运算符"></a>1、算术运算符</h3><ul><li>加、减、乘、除、取余</li><li>算术表达式中包含多个基本数据类型时，整个算术表达式的类型会自动提升<ul><li>byte、short、char类型会将被提升到int类型</li><li>等级顺序 byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double</li></ul></li><li>字符串拼接</li></ul><h3 id="2、赋值运算符"><a href="#2、赋值运算符" class="headerlink" title="2、赋值运算符"></a>2、赋值运算符</h3><ul><li>=</li><li>+=</li></ul><h3 id="3、自增自减运算符"><a href="#3、自增自减运算符" class="headerlink" title="3、自增自减运算符"></a>3、自增自减运算符</h3><ul><li>i++ i– 先用再加</li><li>++i –i 先加再用</li></ul><h3 id="4、关系运算符"><a href="#4、关系运算符" class="headerlink" title="4、关系运算符"></a>4、关系运算符</h3><ul><li>== !=</li><li>&lt; &gt;</li><li>&lt;= &gt;=</li></ul><h3 id="5、逻辑运算符"><a href="#5、逻辑运算符" class="headerlink" title="5、逻辑运算符"></a>5、逻辑运算符</h3><ul><li>&amp; | ^ !</li><li>&amp;&amp; ||</li></ul><h3 id="6、三元运算符"><a href="#6、三元运算符" class="headerlink" title="6、三元运算符"></a>6、三元运算符</h3><ul><li>a&gt;b?a:b</li></ul><h2 id="三、数据输入"><a href="#三、数据输入" class="headerlink" title="三、数据输入"></a>三、数据输入</h2><h3 id="1、Scanner"><a href="#1、Scanner" class="headerlink" title="1、Scanner"></a>1、Scanner</h3><ul><li>导包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure><ul><li>创建对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><ul><li>接收数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = sc.nextInt();</span><br></pre></td></tr></table></figure><ul><li>关闭</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.close();</span><br></pre></td></tr></table></figure><h2 id="四、分支语句"><a href="#四、分支语句" class="headerlink" title="四、分支语句"></a>四、分支语句</h2><h3 id="1、流程控制"><a href="#1、流程控制" class="headerlink" title="1、流程控制"></a>1、流程控制</h3><ul><li>顺序结构</li><li>分支结构</li><li>循环结构</li></ul><h3 id="2、if语句"><a href="#2、if语句" class="headerlink" title="2、if语句"></a>2、if语句</h3><ul><li>if语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式) &#123;</span><br><span class="line">  语句体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if/else语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式) &#123;</span><br><span class="line">  语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>if/连else语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式) &#123;</span><br><span class="line">  语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  语句体n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、switch语句"><a href="#3、switch语句" class="headerlink" title="3、switch语句"></a>3、switch语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    语句体n;</span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    语句体n;</span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、循环语句"><a href="#五、循环语句" class="headerlink" title="五、循环语句"></a>五、循环语句</h2><h3 id="1、for循环语句"><a href="#1、for循环语句" class="headerlink" title="1、for循环语句"></a>1、for循环语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; 条件判断语句; ) &#123;</span><br><span class="line">  循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、while循环语句"><a href="#2、while循环语句" class="headerlink" title="2、while循环语句"></a>2、while循环语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件判断语句) &#123;</span><br><span class="line">  循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、do-while循环语句"><a href="#3、do-while循环语句" class="headerlink" title="3、do/while循环语句"></a>3、do/while循环语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  循环体语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br></pre></td></tr></table></figure><h3 id="4、三种循环语句"><a href="#4、三种循环语句" class="headerlink" title="4、三种循环语句"></a>4、三种循环语句</h3><ul><li>三种循环的区别<ul><li>for和while循环先判断条件是否成立，然后决定是否执行</li><li>do…while循环先执行，在判断条件是否成立</li></ul></li><li>for和while的区别<ul><li>条件控制语句所控制的自增变量，归属于for循环的语法结构中，在for循环结束后，就不能再被访问了</li><li>对于while循环来说不归属其语句结构中，while结构结束后，还可以访问</li></ul></li><li>死循环<ul><li>for( ; ; ) {}</li><li>while(ture) {}</li><li>do {} while(ture);</li></ul></li></ul><h3 id="5、跳转控制语句"><a href="#5、跳转控制语句" class="headerlink" title="5、跳转控制语句"></a>5、跳转控制语句</h3><ul><li>continue 跳过某次循环体内容的执行</li><li>break 终止循环体内容的执行</li></ul><h3 id="6、循环嵌套"><a href="#6、循环嵌套" class="headerlink" title="6、循环嵌套"></a>6、循环嵌套</h3><h3 id="7、Random"><a href="#7、Random" class="headerlink" title="7、Random"></a>7、Random</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> number = r.nextInt(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//获取数据的范围：[0,10)</span></span><br></pre></td></tr></table></figure><h2 id="六、IDEA"><a href="#六、IDEA" class="headerlink" title="六、IDEA"></a>六、IDEA</h2><h3 id="1、IDEA的使用"><a href="#1、IDEA的使用" class="headerlink" title="1、IDEA的使用"></a>1、IDEA的使用</h3><ul><li>project-module-package</li></ul><h3 id="2、快捷语句"><a href="#2、快捷语句" class="headerlink" title="2、快捷语句"></a>2、快捷语句</h3><ul><li>psvm 快速生成main()方法</li><li>sout 快速生成输出语句</li><li>Ctrl+Alt+space 内容提示、代码补全</li><li>Ctrl+Alt+L 格式化</li></ul><h3 id="3、模块"><a href="#3、模块" class="headerlink" title="3、模块"></a>3、模块</h3><h2 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h2><h3 id="1、数组定义格式"><a href="#1、数组定义格式" class="headerlink" title="1、数组定义格式"></a>1、数组定义格式</h3><blockquote><p>一种用于存储多个相同类型数据的存储模型</p></blockquote><ul><li>数据类型[] 变量名<ul><li>int[] arr</li><li>定义了一个int类型的数组，数组名是arr(推荐用这个)</li></ul></li><li>数据类型 变量名[]<ul><li>int arr[]</li><li>定义了一个int类型的变量，变量名是arr数组</li></ul></li></ul><h3 id="2、数组初始化"><a href="#2、数组初始化" class="headerlink" title="2、数组初始化"></a>2、数组初始化</h3><ul><li>动态初始化<ul><li>数据类型[] 变量名 = new 数据类型[数据长度]</li><li>int[] arr = new int[3]<ul><li>int:说明数组中元素类型是int类型,[]:说明这是一个数组,arr:数组名称</li><li>new:为数组申请内存空间,int:说明数组中的元素类型是int类型,[]:说明这是一个数组,3:数组长度</li></ul></li></ul></li><li>静态初始化<ul><li>数据类型[] 变量名 = new 数据类型[] {数据1,数据2,…};<ul><li>int[] arr = new int[]{1,2,3};</li></ul></li><li>数据类型[] 变量名 = {数据1,数据2,数据3,…};<ul><li>int[] arr = {1,2,3};</li></ul></li></ul></li></ul><h3 id="3、数组元素访问"><a href="#3、数组元素访问" class="headerlink" title="3、数组元素访问"></a>3、数组元素访问</h3><ul><li>数组名[索引]<ul><li>索引从0开始</li><li>索引是连续的</li><li>索引逐一增加，每次加1</li></ul></li></ul><h3 id="4、内存分配"><a href="#4、内存分配" class="headerlink" title="4、内存分配"></a>4、内存分配</h3><ul><li>栈内存</li><li>堆内存</li></ul><h3 id="5、常见问题"><a href="#5、常见问题" class="headerlink" title="5、常见问题"></a>5、常见问题</h3><ul><li>索引越界<ul><li>ArrayIndexOutOfBoundsException</li></ul></li><li>空指针异常<ul><li>NullPointerException</li></ul></li></ul><h3 id="6、数组常见操作"><a href="#6、数组常见操作" class="headerlink" title="6、数组常见操作"></a>6、数组常见操作</h3><ul><li>遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  arr[i] <span class="comment">//对arr[i]操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取最值</li></ul><h2 id="八、方法"><a href="#八、方法" class="headerlink" title="八、方法"></a>八、方法</h2><h3 id="1、方法概述"><a href="#1、方法概述" class="headerlink" title="1、方法概述"></a>1、方法概述</h3><blockquote><p>将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码块</p></blockquote><ul><li>方法定义</li><li>方法调用</li></ul><h3 id="2、方法的定义和调用"><a href="#2、方法的定义和调用" class="headerlink" title="2、方法的定义和调用"></a>2、方法的定义和调用</h3><ul><li>定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名() &#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名();</span><br></pre></td></tr></table></figure><h3 id="3、带参数方法的定义和调用"><a href="#3、带参数方法的定义和调用" class="headerlink" title="3、带参数方法的定义和调用"></a>3、带参数方法的定义和调用</h3><ul><li><p>定义</p><ul><li>public static void 方法名() {……}</li><li>public static void 方法名(数据类型 变量名, 数据类型 变量名) {……}</li></ul></li><li><p>调用</p><ul><li>方法名(参数);</li><li>方法名(变量名1/常量名1, 变量名2/常量名2);</li></ul></li><li><p>形参和实参</p><ul><li>形参:方法定义中的参数</li><li>实参:方法调用中的参数</li></ul></li></ul><h3 id="4、带返回值方法的定义和调用"><a href="#4、带返回值方法的定义和调用" class="headerlink" title="4、带返回值方法的定义和调用"></a>4、带返回值方法的定义和调用</h3><ul><li>定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 数据类型 方法名() &#123;</span><br><span class="line">  <span class="keyword">return</span> 数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用<ul><li>数据类型 变量名 = 方法名(参数);</li></ul></li></ul><h3 id="5、方法的注意事项"><a href="#5、方法的注意事项" class="headerlink" title="5、方法的注意事项"></a>5、方法的注意事项</h3><ul><li>方法不能嵌套</li><li>void表示无返回值</li></ul><h3 id="6、方法重载"><a href="#6、方法重载" class="headerlink" title="6、方法重载"></a>6、方法重载</h3><blockquote><p>在同一个类中定义的多个方法之间的关系</p></blockquote><h3 id="7-形参实参"><a href="#7-形参实参" class="headerlink" title="7.形参实参"></a>7.形参实参</h3><ul><li>l</li><li>引用类型</li></ul><h2 id="九、面向对象基础"><a href="#九、面向对象基础" class="headerlink" title="九、面向对象基础"></a>九、面向对象基础</h2><h3 id="1、类和对象"><a href="#1、类和对象" class="headerlink" title="1、类和对象"></a>1、类和对象</h3><blockquote><p>对一类具有共同属性和行为的事物的抽象</p></blockquote><ul><li>类是对象的数据类型</li><li>类是具有相同属性和行为的一组对象的集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  变量<span class="number">1</span>的数据类型 变量<span class="number">1</span>;</span><br><span class="line">  变量<span class="number">2</span>的数据类型 变量<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">  方法<span class="number">1</span>;</span><br><span class="line">  方法<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、成员变量和局部变量"><a href="#2、成员变量和局部变量" class="headerlink" title="2、成员变量和局部变量"></a>2、成员变量和局部变量</h3><table><thead><tr><th align="center">区别</th><th align="center">成员变量</th><th align="center">局部变量</th></tr></thead><tbody><tr><td align="center">类中位置不同</td><td align="center">类中方法外</td><td align="center">方法内或方法声明上</td></tr><tr><td align="center">内存中位置不同</td><td align="center">堆内存</td><td align="center">栈内存</td></tr><tr><td align="center">生命周期不同</td><td align="center">随着对象的存在而存在，随着对象的消失而消失</td><td align="center">随着方法的调用而存在，随着方法的调用完毕而消失</td></tr><tr><td align="center">初始化值不同</td><td align="center">有默认的初始化值</td><td align="center">没有默认的初始化值，必须先定义赋值才能使用</td></tr></tbody></table><h3 id="3、封装"><a href="#3、封装" class="headerlink" title="3、封装"></a>3、封装</h3><h3 id="4、构造方法"><a href="#4、构造方法" class="headerlink" title="4、构造方法"></a>4、构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完成对象数据的初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    修饰符 类名(参数) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法的构建<ul><li>如果没有定义构造方法，系统将给出一个默认的构造方法</li><li>如果定义了构造方法，系统将不再提供默认的构造方法</li></ul></li><li>构造方法的重载<ul><li>如果自定义了带参构造方法，还要使用无参构造方法，就必须再写一个无参数构造方法</li></ul></li><li>推荐<br>无论如何使用，都建议书写无参数构造方法</li></ul><h2 id="十、字符串"><a href="#十、字符串" class="headerlink" title="十、字符串"></a>十、字符串</h2><h3 id="1、API"><a href="#1、API" class="headerlink" title="1、API"></a>1、API</h3><blockquote><p>Application Programming Interface</p></blockquote><h3 id="2、String"><a href="#2、String" class="headerlink" title="2、String"></a>2、String</h3><ul><li>java程序中的双引号字符串，都是String类的对象</li><li>字符串不可变，他们的值在创建后不能被更改</li><li>虽然String的值是不可变的，但是他们可以被共享</li><li>字符串效果上相当于字符数组(char[]),但是底层原理是字节数组(byte[])</li></ul><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public String()</td><td align="center">创建一个空白字符串对象，不含有任何内容</td></tr><tr><td align="center">public String(char[] chs)</td><td align="center">根据字符数组的内容，来创建字符串对象</td></tr><tr><td align="center">public String(byte[] bys)</td><td align="center">根据字节数组的内容，来创建字符串对象</td></tr><tr><td align="center">String s = “abc”</td><td align="center">直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean equals(Object anObject)</td><td align="center">比较字符串的内容</td></tr><tr><td align="center">public char charAt(int index)</td><td align="center">返回指定索引处的char值</td></tr><tr><td align="center">public int length()</td><td align="center">返回此字符串的长度</td></tr></tbody></table><h3 id="3、StringBuilding"><a href="#3、StringBuilding" class="headerlink" title="3、StringBuilding"></a>3、StringBuilding</h3><blockquote><p>可变的字符串类</p></blockquote><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public StringBuilder()</td><td align="center">创建一个空白可变字符串对象，不含有任何内容</td></tr><tr><td align="center">public StringBuilder(String str)</td><td align="center">根据字符串的内容，来创建可变字符串对象</td></tr></tbody></table><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public StringBuilder append(任意类型)</td><td align="center">添加数据，并返回对象本身</td></tr><tr><td align="center">public StringBuilder reverse()</td><td align="center">返回相反的字符序列</td></tr></tbody></table><h3 id="4、String和StringBuilder互相转换"><a href="#4、String和StringBuilder互相转换" class="headerlink" title="4、String和StringBuilder互相转换"></a>4、String和StringBuilder互相转换</h3><ul><li>StringBuilder转换为String<ul><li>public String toString()</li></ul></li><li>String转换为StringBuilder(String s)<ul><li>public StringBuilder(String s):StringBuilder构造函数</li></ul></li></ul><h2 id="十一、集合基础"><a href="#十一、集合基础" class="headerlink" title="十一、集合基础"></a>十一、集合基础</h2><h3 id="1、集合概述"><a href="#1、集合概述" class="headerlink" title="1、集合概述"></a>1、集合概述</h3><blockquote><p>提供一种存储空间可变的存储模型，存储的数据容量可以发生改变</p></blockquote><ul><li>ArrayList&lt; E &gt;:<ul><li>可调整大小的数组实现</li><li>&lt; E &gt;:是一种特殊的数据类型，泛型</li><li>如:ArrayList&lt; String &gt;,ArrayList&lt; Student &gt;</li></ul></li></ul><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public ArrayList()</td><td align="center">创建一个空的集合对象</td></tr><tr><td align="center">public boolean add(E e)</td><td align="center">将指定的元素追加到此集合的末尾</td></tr><tr><td align="center">public void add(int index,E element)</td><td align="center">在此集合中的指定位置插入指定元素</td></tr></tbody></table><ul><li>ArrayList常用方法</li></ul><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean remove(Object o)</td><td align="center">删除指定的元素，返回删除是否成功</td></tr><tr><td align="center">public E remove(int index)</td><td align="center">删除指定索引处的元素，返回被删除的元素</td></tr><tr><td align="center">public E set(int index,E element)</td><td align="center">修改指定索引处的元素，返回被删除的元素</td></tr><tr><td align="center">public E get(int index)</td><td align="center">返回指定索引处的元素</td></tr><tr><td align="center">public int size()</td><td align="center">返回集合中的元素的个数</td></tr></tbody></table><h2 id="十二、继承"><a href="#十二、继承" class="headerlink" title="十二、继承"></a>十二、继承</h2><h3 id="1、继承概述"><a href="#1、继承概述" class="headerlink" title="1、继承概述"></a>1、继承概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 父类名 </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2、好处及弊端"><a href="#2、好处及弊端" class="headerlink" title="2、好处及弊端"></a>2、好处及弊端</h3><ul><li>好处<ul><li>提高了代码的复用性</li><li>提高了代码的维护性</li></ul></li><li>弊端<ul><li>子类和父类耦合性提高，独立性降低</li></ul></li></ul><h3 id="3、super"><a href="#3、super" class="headerlink" title="3、super"></a>3、super</h3><ul><li>this代表本类对象的引用</li><li>super代表父类存储空间的标识</li></ul><table><thead><tr><th align="center">关键字</th><th align="center">访问成员变量</th><th align="center">访问构造方法</th><th align="center">访问成员方法</th></tr></thead><tbody><tr><td align="center">this</td><td align="center">this.成员变量</td><td align="center">this(…)</td><td align="center">this.成员方法()</td></tr><tr><td align="center">super</td><td align="center">super.成员变量</td><td align="center">super(…)</td><td align="center">super.成员方法()</td></tr></tbody></table><h3 id="4、继承中构造方法的访问特点"><a href="#4、继承中构造方法的访问特点" class="headerlink" title="4、继承中构造方法的访问特点"></a>4、继承中构造方法的访问特点</h3><ul><li>子类中所有的构造方法默认都会访问父类中无参的构造方法<ul><li>因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化</li><li>每一个子类构造方法的第一条语句默认都是：super()</li></ul></li><li>如果父类中没有无参构造方法，只有带参构造方法，该如何办？<ul><li>通过使用super关键字去显示的调用父类的带参构造方法</li><li>在父类中自己提供一个无参构造方法</li></ul></li></ul><h3 id="5、继承中成员方法的访问特点"><a href="#5、继承中成员方法的访问特点" class="headerlink" title="5、继承中成员方法的访问特点"></a>5、继承中成员方法的访问特点</h3><ul><li>通过子类对象访问一个方法<ul><li>首先在子类成员范围找</li><li>然后在父类成员范围找</li><li>如果都没有就报错</li></ul></li></ul><h3 id="6、方法重写"><a href="#6、方法重写" class="headerlink" title="6、方法重写"></a>6、方法重写</h3><ul><li>子类中出现和父类中一模一样的方法声明</li><li>方法重写的应用<ul><li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。</li></ul></li></ul><blockquote><p>@Override</p></blockquote><ul><li>是一个注解</li><li>可以帮助检查重写方法声明的正确性</li></ul><h3 id="7、方法重写的注意事项"><a href="#7、方法重写的注意事项" class="headerlink" title="7、方法重写的注意事项"></a>7、方法重写的注意事项</h3><ul><li>私有方法不能被重写（父类私有成员子类是不能继承的）</li><li>子类方法访问权限不能更低(public&gt;默认&gt;私有)</li></ul><h3 id="8、java中继承的注意事项"><a href="#8、java中继承的注意事项" class="headerlink" title="8、java中继承的注意事项"></a>8、java中继承的注意事项</h3><ul><li>Java中类只支持单继承，不支持多继承</li><li>java中类支持多层继承</li></ul><h2 id="十三、修饰符"><a href="#十三、修饰符" class="headerlink" title="十三、修饰符"></a>十三、修饰符</h2><h3 id="1、包"><a href="#1、包" class="headerlink" title="1、包"></a>1、包</h3><blockquote><p>就是文件夹，对类进行分类管理</p></blockquote><ul><li>自动建包<ul><li>编译 javac -d . HelloWorld.java</li><li>运行 java 包名.HelloWorld</li></ul></li></ul><h3 id="2、导包"><a href="#2、导包" class="headerlink" title="2、导包"></a>2、导包</h3><ul><li>可以直接使用，写清类的全路径 包名.函数()<ul><li>如 java.util.Scanner</li></ul></li><li>导包<ul><li>import java.util.Scanner</li></ul></li></ul><h3 id="3、修饰符"><a href="#3、修饰符" class="headerlink" title="3、修饰符"></a>3、修饰符</h3><h4 id="1、权限修饰符"><a href="#1、权限修饰符" class="headerlink" title="1、权限修饰符"></a>1、权限修饰符</h4><table><thead><tr><th align="center">修饰符</th><th align="center">同一类中</th><th align="center">同一包中的子类或无关类</th><th align="center">不同包的子类</th><th align="center">不同包的无关类</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">T</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">默认</td><td align="center">T</td><td align="center">T</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">protected</td><td align="center">T</td><td align="center">T</td><td align="center">T</td><td align="center"></td></tr><tr><td align="center">public</td><td align="center">T</td><td align="center">T</td><td align="center">T</td><td align="center">T</td></tr></tbody></table><h4 id="2、状态修饰符"><a href="#2、状态修饰符" class="headerlink" title="2、状态修饰符"></a>2、状态修饰符</h4><ul><li>final<ul><li><blockquote><p>可以修饰成员方法，成员变量，类</p></blockquote><ul><li>修饰方法：表明该方法是最终方法，不能被重写</li><li>修饰变量：表明该变量是常量，不能再次被赋值</li><li>修饰类：表明该类是最终类，不能被继承</li></ul></li><li><blockquote><p>修饰局部变量</p></blockquote><ul><li>变量是基本类型：final修饰指的是基本类型的数据值不能发生变化</li><li>变量是引用类型：final修饰指的是引用类型的地址值不能发生改变，但是地址里面的内容可以发生变化</li></ul></li></ul></li><li>static<ul><li><blockquote><p>修饰成员方法，成员变量</p></blockquote><ul><li>被类的所有对象共享</li><li>可用通过类名调用(推荐)</li></ul></li><li>非静态成员方法访问特点<ul><li>可以访问所有，静态或非静态成员变量，静态或非静态成员方法</li></ul></li><li>静态成员方法<ul><li>只可以访问静态成员方法或变量</li></ul></li></ul></li></ul><h2 id="十四、多态"><a href="#十四、多态" class="headerlink" title="十四、多态"></a>十四、多态</h2><h3 id="1、多态概述"><a href="#1、多态概述" class="headerlink" title="1、多态概述"></a>1、多态概述</h3><blockquote><p>同一个对象，在不同时刻表现出来的不同形态</p></blockquote><ul><li>多态的前提和体现<ul><li>有继承/实现关系</li><li>有方法重写</li><li>有父类引用指向子类对象</li></ul></li><li>多态中成员访问特点<ul><li>成员变量：编译看左边，执行看左边</li><li>成员方法：编译看左边，执行看右边</li></ul></li><li>为什么成员变量和成员方法的访问不一样呢<ul><li>因为成员方法有重写，而成员变量没有</li></ul></li><li>多态转型<ul><li>向上转型<ul><li>从子到父</li><li>父类引用指向子类对象</li></ul></li><li>向下转型<ul><li>从父到子</li><li>父类引用转为子类对象</li></ul></li></ul></li></ul><h3 id="2、抽象类"><a href="#2、抽象类" class="headerlink" title="2、抽象类"></a>2、抽象类</h3><blockquote><p>在java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类</p></blockquote><ul><li>抽象类和抽象方法必须使用abstract关键字修饰</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象类中不一定有抽象方法，但抽象方法的类一定是抽象类</li><li>抽象类不能实例化<ul><li>抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态</li></ul></li><li>抽象类的子类<ul><li>要么重写抽象类中的所有抽象方法</li><li>要么是抽象类</li></ul></li><li>抽象类的访问特点<ul><li>成员变量<ul><li>可以是变量，也可以是常量</li></ul></li><li>构造方法<ul><li>有构造方法，但是不能实例化</li><li>构造方法的作用：用于子类访问父类数据的初始化</li></ul></li><li>成员方法<ul><li>可以有抽象方法，限定子类必须完成某些方法(即必须重写)</li><li>可以有非抽象方法，提高代码复用性</li></ul></li></ul></li></ul><h3 id="3、接口"><a href="#3、接口" class="headerlink" title="3、接口"></a>3、接口</h3><blockquote><p>接口就是一种公共的规范标准，java中的接口更多的体现在对行为的抽象</p></blockquote><ul><li>接口特点<ul><li>接口用关键字interface修饰<ul><li>public interface 接口名{}</li></ul></li><li>类实现接口用implement表示<ul><li>public class 类名 implements 接口名 {}</li></ul></li><li>接口不能实例化<ul><li>接口如何实例化？参照多态形式，通过实现类对象实例化</li><li>多态的形式：具体类多肽，抽象类多态，接口多态</li><li>多态的前提：有继承或实现关系；有方法重写；有父(类/接口)引用指向(子/实现)类对象</li></ul></li><li>接口的实现类<ul><li>要么重写接口中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ul></li><li>接口的成员特点<ul><li>成员变量<ul><li>只能是常量</li><li>默认修饰符:public static final</li></ul></li><li>构造方法<ul><li>接口没有构造方法，因为接口主要对行为进行抽象的，没有具体存在</li><li>一个类如果没有父类，默认继承自Object类</li></ul></li><li>成员方法<ul><li>只能是抽象方法</li><li>默认修饰符:public abstract</li></ul></li></ul></li><li>类和接口的关系<ul><li>类和类的关系<ul><li>继承关系，只能单继承，但是可以多层继承</li></ul></li><li>类和接口的关系<ul><li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li></ul></li><li>接口和接口的关系<ul><li>继承关系，可以单继承，也可以多继承</li></ul></li></ul></li><li>抽象类和接口的区别<ul><li>成员区别<ul><li>抽象类：变量，常量;有构造方法;有抽象方法，也有非抽象方法</li><li>接口：常量;抽象方法</li></ul></li><li>设计理念区别<ul><li>抽象类：对象抽象，包括属性、行为</li><li>接口：对行为抽象，主要是行为</li></ul></li></ul></li></ul><h2 id="十五、形参和返回值"><a href="#十五、形参和返回值" class="headerlink" title="十五、形参和返回值"></a>十五、形参和返回值</h2><h3 id="1、形参和返回值"><a href="#1、形参和返回值" class="headerlink" title="1、形参和返回值"></a>1、形参和返回值</h3><h4 id="1、类名作为形参和返回值"><a href="#1、类名作为形参和返回值" class="headerlink" title="1、类名作为形参和返回值"></a>1、类名作为形参和返回值</h4><ul><li>方法的形参是类名，其实需要的是该类的对象</li><li>方法的返回值是类名，其实返回的是该类的对象</li></ul><h4 id="2、抽象类名作为形参和返回值"><a href="#2、抽象类名作为形参和返回值" class="headerlink" title="2、抽象类名作为形参和返回值"></a>2、抽象类名作为形参和返回值</h4><ul><li>方法的形参是抽象类名，其实需要的是该抽象类的子类对象</li><li>方法的返回值是抽象类名，其实返回的是该抽象类的子类对象</li></ul><h4 id="3、接口名作为形参和返回值"><a href="#3、接口名作为形参和返回值" class="headerlink" title="3、接口名作为形参和返回值"></a>3、接口名作为形参和返回值</h4><ul><li>方法的形参是接口名，其实需要的是该接口的实现类对象</li><li>方法的返回值是接口名，其实返回的是该接口的实现类对象</li></ul><h3 id="2、内部类"><a href="#2、内部类" class="headerlink" title="2、内部类"></a>2、内部类</h3><blockquote><p>内部类:就是在一个类中定义一个类</p></blockquote><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><h4 id="1、成员内部类"><a href="#1、成员内部类" class="headerlink" title="1、成员内部类"></a>1、成员内部类</h4><ul><li>格式 外部类名.内部类名 对象名 = 外部类对象.内部类对象;</li><li>如 Outer.Inner oi = new Outer().new Inner();</li></ul><h4 id="2、局部内部类"><a href="#2、局部内部类" class="headerlink" title="2、局部内部类"></a>2、局部内部类</h4><ul><li>局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li></ul><h4 id="3、匿名内部类-局部内部类一种"><a href="#3、匿名内部类-局部内部类一种" class="headerlink" title="3、匿名内部类-局部内部类一种"></a>3、匿名内部类-局部内部类一种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">  重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本质：是一个继承了该类或者实现了该接口的子类匿名对象</p></blockquote><h3 id="3、常用API"><a href="#3、常用API" class="headerlink" title="3、常用API"></a>3、常用API</h3><h4 id="1、MATH"><a href="#1、MATH" class="headerlink" title="1、MATH"></a>1、MATH</h4><h4 id="2、System"><a href="#2、System" class="headerlink" title="2、System"></a>2、System</h4><ul><li>exit():非零表示异常终止</li><li>currentTimeMillis():返回当前时间与1970年1月1日之间的时间(ms)</li></ul><h4 id="3、Object"><a href="#3、Object" class="headerlink" title="3、Object"></a>3、Object</h4><blockquote><p>Object是类层次结构的根</p></blockquote><ul><li>tostring()返回对象的字符串表示形式，建议重写，自动生成</li><li>equals()比较对象是否相等，默认是比较地址，重写可以比较内容，自动生成</li></ul><h4 id="4、Arrays"><a href="#4、Arrays" class="headerlink" title="4、Arrays"></a>4、Arrays</h4><ul><li>冒泡排序</li></ul><blockquote><p>对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序。</p></blockquote><ul><li>toString()返回指定数组的内容的字符串表示形式</li><li>sort()按照数字顺序排列指定的数组</li></ul><h4 id="5、基本类型包装类"><a href="#5、基本类型包装类" class="headerlink" title="5、基本类型包装类"></a>5、基本类型包装类</h4><blockquote><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据常用的操作之一：用于基本数据类型与字符串之间得转换</p></blockquote><ul><li>Interger<ul><li>valueof</li></ul></li><li>int和string相互转换<ul><li>int-&gt;string<ul><li>1、String s1 = “” + number;</li><li>2、String s2 = String.valueOf(number);</li></ul></li><li>string-&gt;int<ul><li>1、Integer i = Integer.valueOf(s); int x = i.intValue();</li><li>2、int y = Integer.parseInt(s);</li></ul></li></ul></li><li>自动装箱和拆箱<ul><li>装箱：把基本数据类型转换为对应的包装类类型</li><li>拆箱：把包装类类型转换成对应的基本数据类型</li><li>在使用包装类型时，如果要操作，最好先判断是否为NULL</li></ul></li></ul><h4 id="6、日期类"><a href="#6、日期类" class="headerlink" title="6、日期类"></a>6、日期类</h4><h5 id="1、基本"><a href="#1、基本" class="headerlink" title="1、基本"></a>1、基本</h5><ul><li>Date();</li><li>getTime(); 获取的是日期对象从1970.1.1到现在的毫秒值</li><li>setTime();</li></ul><h5 id="2、SimpleDateFormat"><a href="#2、SimpleDateFormat" class="headerlink" title="2、SimpleDateFormat"></a>2、SimpleDateFormat</h5><ul><li>日期格式化和解析</li><li>y-年 M-月 d-日 H-时 m-分 s-秒</li><li>格式化(从Date到String)<ul><li>format(Date date):从日期格式化成日期/时间字符串</li></ul></li><li>解析(从String到Date)<ul><li>parse(String source):从给定字符串的开始解析文本以生成日期</li></ul></li></ul><h5 id="3、Calendar"><a href="#3、Calendar" class="headerlink" title="3、Calendar"></a>3、Calendar</h5><ul><li>get() 返回给定日历字段的值,int year = c.get(Calendar.YEAR)</li><li>add()</li><li>set() 设置当前日历的年月日</li></ul><h3 id="4、异常"><a href="#4、异常" class="headerlink" title="4、异常"></a>4、异常</h3><ul><li>try{} catch() {}</li><li>throws 异常类名</li><li>throw</li></ul><h4 id="1、Throwable"><a href="#1、Throwable" class="headerlink" title="1、Throwable"></a>1、Throwable</h4><ul><li>getMessage() 返回此throwable的详细消息字符串</li><li>toString() 返回此可抛出的简短描述</li><li>printStackTrace() 把异常的错误信息输出在控制台</li></ul><h2 id="十六、集合进阶"><a href="#十六、集合进阶" class="headerlink" title="十六、集合进阶"></a>十六、集合进阶</h2><ul><li>集合<ul><li>Collection 单列<ul><li>List 元素可重复<ul><li>ArryList</li><li>LinkedList</li></ul></li><li>Set 元素不可重复<ul><li>HashSet</li><li>TreeSet</li></ul></li></ul></li><li>Map 双列<ul><li>HashMap</li></ul></li></ul></li></ul><h3 id="1、Collection"><a href="#1、Collection" class="headerlink" title="1、Collection"></a>1、Collection</h3><h4 id="1、常用方法"><a href="#1、常用方法" class="headerlink" title="1、常用方法"></a>1、常用方法</h4><ul><li>add() 添加元素</li><li>remove() 从集合中移除指定元素</li><li>clear() 清空集合中的元素</li><li>contains() 判断集合中是否存在指定的元素</li><li>isEmpty() 判断集合是否为空</li><li>size() 集合的长度，即集合中元素个数</li></ul><h4 id="2、遍历"><a href="#2、遍历" class="headerlink" title="2、遍历"></a>2、遍历</h4><p>Iterator:迭代器，集合专用遍历方式</p><ul><li>Iterator <E> iterator:返回此集合中元素的迭代器</E></li><li>E next():返回迭代中的下一个元素</li><li>bolean hasNext():如果迭代具有更多元素，则返回true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">  String s = it.next();</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h3><p>有序集合(序列)</p><h4 id="1、方法"><a href="#1、方法" class="headerlink" title="1、方法"></a>1、方法</h4><ul><li><p>add()</p></li><li><p>remove()</p></li><li><p>set()</p></li><li><p>get()</p></li><li><p>并发修改异常</p><ul><li>原因:迭代过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</li><li>解决方案:用for循环遍历，然后用集合对象做相应操作即可</li></ul></li></ul><h4 id="2、迭代器ListIterator"><a href="#2、迭代器ListIterator" class="headerlink" title="2、迭代器ListIterator"></a>2、迭代器ListIterator</h4><ul><li>E next();</li><li>boolean hasNext();</li><li>E previous();</li><li>boolean hasPrevious();</li><li>void add(E e);</li></ul><h4 id="3、增强for循环"><a href="#3、增强for循环" class="headerlink" title="3、增强for循环"></a>3、增强for循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">  对i操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、数据结构"><a href="#3、数据结构" class="headerlink" title="3、数据结构"></a>3、数据结构</h3><ul><li>栈 先进后出</li><li>队列 先进先出</li><li>数组 查询快，增删慢</li><li>链表 增删快，查询必须从头(head)开始(对比数组)</li></ul><h3 id="4、list集合子类"><a href="#4、list集合子类" class="headerlink" title="4、list集合子类"></a>4、list集合子类</h3><ul><li>ArrayList:底层数据结构是数组，查询快，增删慢</li><li>LinkedList:底层数据结构是链表，查询慢，增删快</li></ul><h3 id="5、set集合"><a href="#5、set集合" class="headerlink" title="5、set集合"></a>5、set集合</h3><h4 id="1、Hash值"><a href="#1、Hash值" class="headerlink" title="1、Hash值"></a>1、Hash值</h4><blockquote><p>哈希值:是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值</p></blockquote><ul><li>默认情况下，同一对象的哈希值是相同的，不同对象的哈希值是不同的</li><li>通过方法重写，可以实现不同对象的哈希值是相同的</li></ul><h3 id="6、HashSet"><a href="#6、HashSet" class="headerlink" title="6、HashSet"></a>6、HashSet</h3><ul><li>哈希表</li></ul><h3 id="7、LinedHashSet"><a href="#7、LinedHashSet" class="headerlink" title="7、LinedHashSet"></a>7、LinedHashSet</h3><ul><li>哈希表和链表实现的set接口，具有可预测的迭代顺序</li><li>由链表保证元素有序，元素存储和取出的顺序是一致的</li><li>由哈希表保证元素唯一，没有重复的元素</li></ul><h3 id="8、TreeSet"><a href="#8、TreeSet" class="headerlink" title="8、TreeSet"></a>8、TreeSet</h3><ul><li>元素有序<ul><li>TreeSet():根据其元素的自然排序进行排序,如从小到大，从a到z</li><li>TreeSet(Comparator comparator):根据指定额比较器进行排序</li></ul></li><li>没有带索引的方法，不能使用普通for循环遍历</li><li>不包含重复元素</li></ul><p>比较器排序Comparator的使用</p><ul><li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li><li>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1, T o2)方法</li><li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li></ul><h3 id="9、泛型"><a href="#9、泛型" class="headerlink" title="9、泛型"></a>9、泛型</h3><h4 id="1、泛型类"><a href="#1、泛型类" class="headerlink" title="1、泛型类"></a>1、泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2、泛型方法"><a href="#2、泛型方法" class="headerlink" title="2、泛型方法"></a>2、泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;&#125; </span><br></pre></td></tr></table></figure><h4 id="3、泛型接口"><a href="#3、泛型接口" class="headerlink" title="3、泛型接口"></a>3、泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4、类型通配符"><a href="#4、类型通配符" class="headerlink" title="4、类型通配符"></a>4、类型通配符</h4><ul><li>类型通配符:&lt;?&gt;<ul><li>List&lt;?&gt;:可以匹配任意类型</li></ul></li><li>类型通配符上限:&lt;? extends 类型&gt;<ul><li>List&lt;? extends Number&gt;:表示的类型是Number或者其子类型</li></ul></li><li>类型通配符下限:&lt;? super 类型&gt;<ul><li>List&lt;? super Number&gt;:表示的类型是Number或者其父类型</li></ul></li></ul><h3 id="10、Map-HashMap"><a href="#10、Map-HashMap" class="headerlink" title="10、Map/HashMap"></a>10、Map/HashMap</h3><h4 id="1、方法-1"><a href="#1、方法-1" class="headerlink" title="1、方法"></a>1、方法</h4><ul><li>put():添加元素</li><li>remove():根据键删除键对应元素</li><li>clear():移除所有的键值对元素</li><li>containsKey():判断集合是否包含指定的键</li><li>containsValue():判断集合是否包含指定的值</li><li>isEmpty():判断集合是否为空</li><li>size():集合的长度</li></ul><h4 id="2、遍历-1"><a href="#2、遍历-1" class="headerlink" title="2、遍历"></a>2、遍历</h4><ul><li>法一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key : keySet) &#123;</span><br><span class="line">  String value = map.get(key);</span><br><span class="line">  System.out.println(key + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>法二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>&lt;Map.Entry&lt;String, String&gt; en : entrySet&gt; &#123;</span><br><span class="line">  String key = en.getKey();</span><br><span class="line">  String value = en.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、Collections"><a href="#11、Collections" class="headerlink" title="11、Collections"></a>11、Collections</h3><h4 id="1、方法-2"><a href="#1、方法-2" class="headerlink" title="1、方法"></a>1、方法</h4><ul><li>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list):将指定的列表按升序排序</T></li><li>public static void reverse(List&lt;?&gt; list):反转指定列表中元素的顺序</li><li>public static void shuffle(list&lt;?&gt; list):指定默认的随机源随机排列指定的列表</li></ul><h2 id="十七、文件、IO流数据处理"><a href="#十七、文件、IO流数据处理" class="headerlink" title="十七、文件、IO流数据处理"></a>十七、文件、IO流数据处理</h2><h3 id="1、File类"><a href="#1、File类" class="headerlink" title="1、File类"></a>1、File类</h3><p>File:是文件和目录路径名的抽象表示</p><ul><li><p>文件和目录是可以通过File封装成对象的</p></li><li><p>File(String pathname):通过给定的路径名字符串转换成抽象路径名来创建新的File实例</p></li><li><p>File(String parent, String child):从父路径名字符串和子路径名字符串创建新的File实例</p></li><li><p>File(File parent, String child):从父抽象路径名和子路径名字符串创建新的File实例</p></li><li><p>createNewFile():当具有该文件名称的文件不存在时，创建一个由该抽象路径名的新空文件夹</p></li><li><p>mkdir():创建由此抽象路径名命名的目录</p></li><li><p>mkdirs():创建由此抽象路径名命名的目录，包括任何必须但不存在的父目录</p></li></ul><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h3 id="2、字节流"><a href="#2、字节流" class="headerlink" title="2、字节流"></a>2、字节流</h3><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>启动多线程 myThread.start()</li><li>setName():设置线程名称</li><li>getName():返回此线程名称</li><li>currentThread():获取当前线程名称</li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul><li>setPriority():设置线程优先级，1-10</li><li>getPriority():获取线程优先级</li><li>sleep():使当前正在执行的线程停留指定毫秒数</li><li>join():等待这个线程死亡</li><li>setDaemon(boolean on):守护线程</li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>网络编程三要素：IP地址，端口和协议</p><h3 id="1、InetAddress"><a href="#1、InetAddress" class="headerlink" title="1、InetAddress"></a>1、InetAddress</h3><ul><li>static InetAddress getByName(String host):确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP名称</li><li>String getHostName():获取此IP地址的主机名</li><li>String getHostAddress():返回文本显示中的IP地址字符串</li></ul><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><ul><li>格式:(形式参数) -&gt; {代码块}</li><li>形式参数:如果有多个参数，参数之间用逗号隔开;如果没有参数，留空</li><li>-&gt;:由英文中画线和大于号组成，固定写法。代表指定动作</li><li>代码块:具体要做的内容</li><li>适用前提:有一个接口，接口中有且仅有一个抽象方法</li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2>]]></content>
    
    
    <summary type="html">学习java入门</summary>
    
    
    
    <category term="学习笔记" scheme="http://ykhou.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://ykhou.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下VsCode无法使用中文</title>
    <link href="http://ykhou.gitee.io/2021/01/10/Ubuntu%E4%B8%8BVSCode%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/"/>
    <id>http://ykhou.gitee.io/2021/01/10/Ubuntu%E4%B8%8BVSCode%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/</id>
    <published>2021-01-10T08:20:24.000Z</published>
    <updated>2021-02-19T07:59:06.363Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问题描述：我的vscode 是在商城(Ubuntu Software)下载的，使用时发现居然切换不了中文输入法！<br>百度发现商城中的vscode是snap的削减版本，不支持中文。<br>解决方法：直接到官网下载然后安装就可以了。</p></blockquote><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><ul><li><p>1、卸载snap版本</p><p><code>sudo snap remove code</code></p></li><li><p>2、下载官网VSCode</p><p> 官网 <a class="link" href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download<i class="fas fa-external-link-alt"></i></a></p></li><li><p>安装</p><p><code>sudo dpkg -i code_1.52.1-1608136922_amd64.deb</code></p></li></ul><h2 id="关于rpm和deb"><a href="#关于rpm和deb" class="headerlink" title="关于rpm和deb"></a>关于rpm和deb</h2><ul><li>RPM(Red Hat Package Manager)，是基于Red hat的Linux Distribution的包管理系统，同时也指rpm包本身，RPM用于rpm包的管理（诸如安装、卸载、升级等），rpm包主要用于redhat及分支如redhat，centos，Fedora等</li><li>deb包主要用于debian及分支如debian，ubuntu等。</li></ul>]]></content>
    
    
    <summary type="html">如何解决linux下vscode无法切换输入法的问题</summary>
    
    
    
    <category term="知识分享" scheme="http://ykhou.gitee.io/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="VsCode" scheme="http://ykhou.gitee.io/tags/VsCode/"/>
    
    <category term="输入法" scheme="http://ykhou.gitee.io/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
</feed>
